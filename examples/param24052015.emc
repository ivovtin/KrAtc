// Параметры реконструкции в электромагнитном калориметре.
// Обозначения: 
// lkr - башни в криптоне, str - полоски, csi - кристаллы, emc - lkr+csi
// See different tips at the end of this file


///////////////////////////////////////////////////////////////////////////////
// ОСНОВНОЕ УПРАВЛЕНИЕ РЕКОНСТРУКЦИЕЙ                                        //
///////////////////////////////////////////////////////////////////////////////

emc_verbose=1;                 // печать на экран (см. описание ниже)
emc_master=1;                  // если 0, то emc_all() управляется от kglobalparam

read_lkr=1;                    // читать LKr запись, заполнять массив[9600] с амплитудами
read_csi=1;                    // читать CsI запись, заполнять массив[1536] с амплитудами

rec_lkr=1;                     // искать кластеры в LKr(башни)
rec_csi=1;                     // искать кластеры в CsI
rec_str=1;                     // искать кластеры в LKr(полоски)
rec_str_tracks=1;              // строить треки по LKr(полоски)

attach_lkr2str=1;              // приписывать башенным кластерам полосочные (только криптон)
attach_lkr2csi=1;              // приписывать кластеры LKr(башни) кластерам CsI. И наоборот.
attach_lkr2dc=0;               // приписывать кластеры LKr(башни) трекам ДК 
attach_csi2dc=0;               // приписывать кластеры CsI трекам ДК

fill_structure=1;              // заполнять C-структуру из emc_system.h с данными реконструкции (для пользователей фортрана)


///////////////////////////////////////////////////////////////////////////////
// ЭНЕРГИЯ                                                                   //
///////////////////////////////////////////////////////////////////////////////

lkr_scale=1.0,   1.0;          // множитель энергии в LKr (exp,sim)
csi_scale=0.897, 1.0;          // множитель энергии в CsI (exp,sim)
lkr_scale_cosm = 1;            // экспериментальный scale поправляется на космический коэффициент  из БД

lkr_simnoise=1;                // мешать шумы в моделирование (соответственно намоделировано должно быть без шумов)
csi_simnoise=1;                // мешать шумы в моделирование (соответственно намоделировано должно быть без шумов)
csi_noisepars=0.2,3.0;         // шум в канале (МэВ), величина порога(в сигмах шума) для имитирования чтения с превышением

sim4exp_bad=1;                 // загружает из БД экспериментальные списки плохих каналов при обработке моделирования(см. ниже)

csi_bad_channels = 2;          // учет плохих каналов 0/1/2 - не учитывать, основываться на mev2ch, читать из БД

lkr_bad_mode = 1;              // 1 - учитывать звенящие (kRING) как поломанные(kBROKEN)
csi_bad_mode = 3;              // 1 - учитывать звенящие (kRING) как поломанные(kBROKEN)
                               // 2 - учитывать звенящие^2 (kRING2) как kBROKEN, 3=1+2.

csi_mev2ch_tid = 1520;         // номер таблицы для коэффициента мэв/канал, если 0, то брать из файла
csi_mev2ch_fname =/space/users/pospelov/csicalib2/5477-5579_1/csimev2ch.txt; // имя файла

lkr_mev2ch_tid = 1657,0;       // номер таблицы для mev2ch и ее версия


///////////////////////////////////////////////////////////////////////////////
// СТРОИТЕЛЬСТВО                                                             //
///////////////////////////////////////////////////////////////////////////////

// параметры для поиска кластеров в LKr башнях 
lkr_cell_ecut=1.5, 1.5, 8.0;   // пороги (МэВ) на энергию для включения ячеек в кластер (cell, near, seed)
lkr_cell_rcut=2.5, 3.0, 4.0;   // пороги на сигнал/шум для включения ячеек в кластер (cell, near, seed)
lkr_cluster_ecut=10.;          // порог (МэВ) на энергию кластера
lkr_cluster_ncells=1;          // порог снизу на число ячеек в кластере (оно должно быть не меньше указанного)
lkr_merge=3;                   // 1- сливать граничные, 2- сливать через плохую ячейку, 3- 1+2
lkr_wincut=0;                  // размер окна, ограничивающего распространение кластера

// параметры для поиска кластеров в CsI
csi_cell_ecut=1.0, 1.5, 8.0;   // пороги (МэВ) на энергию для включения ячеек в кластер (cell, near, seed)
csi_cluster_ecut=10.;          // порог (МэВ) на энергию кластера
csi_cluster_ncells=1;          // порог снизу на число ячеек в кластере (оно должно быть не меньше указанного)
csi_merge=3;                   // 1- сливать граничные, 2- сливать через плохую ячейку, 3- 1+2
csi_wincut=0;                  // размер окна, ограничивающего распространение кластера

// параметры для поиска кластеров в LKr полосках
str_cell_ecut=0.5, 0.5, 3.;   // пороги (МэВ) на энергию для включения ячеек в кластер (cell, near, seed)
//str_cell_ecut=0.9, 0.9, 4.;   // пороги (МэВ) на энергию для включения ячеек в кластер (cell, near, seed)
str_cell_rcut=2.0, 2.0, 4.0;   // пороги на сигнал/шум для включения ячеек в кластер (cell, near, seed)
str_cluster_ecut=3.0;          // порог (МэВ) на энергию кластера
str_cluster_ncells=2;          // порог снизу на число ячеек в кластере (оно должно быть не меньше указанного)
str_merge=0;                   // 1- сливать граничные, 2- сливать через плохую ячейку, 3- 1+2
str_wincut=0;                  // размер окна, ограничивающего распространение кластера

// параметры для построения треков по полоскам
str_tracks_merge=0;            // сливать короткие треки в длинные (космика)
str_tracks_angle=20.;          // порог на угол между треками на слияние
str_tracks_distance=20.;       // порог на расстояние между x0,y0,z0 двух треков


///////////////////////////////////////////////////////////////////////////////
// ПРИСОЕДИНЕНИЕ ОДНОГО К ДРУГОМУ                                            //
///////////////////////////////////////////////////////////////////////////////

// параметры на присоединение полосок к башенным кластерам
lkr2str_theta=2.0, 5.0, 20.0;  // пороги по theta (nsig,ths_min,ths_max) (см. ниже)
lkr2str_phi=2.0, 5.0, 20.0;    // пороги по phi (nsig,ths_min,ths_max) (см. ниже)
lkr2str_zphi=10.0, 2.5;        // пороги по phi для z-полосок (стык)

// параметры на присоединение кластеров LKr(башни) к трекам ДК
lkr2dc_theta=5.0, 10.0, 20.0;  // пороги по theta (nsig,ths_min,ths_max) (см. ниже)
lkr2dc_phi=5.0, 10.0, 20.0;     // пороги по phi (nsig,ths_min,ths_max) (см. ниже)

// параметры на присоединение кластеров LKr(башни) кластерам CsI
lkr2csi_theta=5.0, 15.0, 20.0; // пороги по theta (nsig,ths_min,ths_max) (см. ниже)
lkr2csi_phi=5.0, 15.0, 20.0;   // пороги по phi (nsig,ths_min,ths_max) (см. ниже)

// параметры на присоединение кластеров CsI к трекам ДК
csi2dc_theta=3.0, 10.0, 15.0;  // пороги по theta (nsig,ths_min,ths_max) (см. ниже)
csi2dc_phi=3.0, 10.0, 15.0;    // пороги по phi (nsig,ths_min,ths_max) (см. ниже)


///////////////////////////////////////////////////////////////////////////////
// РАЗНОЕ                                                                    //
///////////////////////////////////////////////////////////////////////////////

// сдвигать LKr и CsI в систему координат ДК
lkrshift=0;
csishift=1;
//emcshift_fname=/space/KEDR/stable/KEmcData/emcshift.txt; // файл со сдвигами LKr и CsI относительно ДК
emcshift_fname=/space/KEDR/stable/KEmcData/emcshift_loc3.txt; // файл со сдвигами CsI относительно LKr

// служебные параметры
emc_debug=0;                   // служебная печать, см. ниже
emc_debug_field=1,1,1,0,0;     // lkr, csi, str, str_track, dc_track
emc_param_id=5;                // служебный стимулятор пользователя

///////////////////////////////////////////////////////////////////////////////////
// - Tips 
// - Если строчки выкинуть или закомментировать, возьмутся значения по умолчанию.
// - Строчки можно переставлять местами.
// - Если например отключить чтение криптона read_lkr=0, то реконструкция в
//   нем отключится сама (т.е. необязательно еще делать и rec_lkr=0, rec_str=0, ...)
// - Важно: если вы передаете имя файла, как например в карте 
//   emcshift_fname=/home/pospelov/KEDR/KEmcData/emcshift_loc.txt;
//   то не должно быть пробела после знака '='
///////////////////////////////////////////////////////////////////////////////////

//  emc_verbose
//  0- отсутствие печати. 1- +самое необходимое. 2- +некритичные предупреждения.
//  10 - +все подряд.

// attach_lkr2str
// Полосочный кластер присоединяется к башенному, если выполняются соотношения
// fabs(lkr_theta-str_theta) < THS_THETA && fabs(lkr_phi-str_phi) < THS_PHI
// Здесь порог THS_THETA(в градусах) насчитывается исходя их карты
// lkr2str_theta=nsig, ths_min, ths_max;
// THS_THETA=nsig*(размер dtheta башенного кластера по theta в градусах), но
// если THS_THETA<ths_min то THS_THETA=ths_min
// если THS_THETA>ths_max то THS_THETA=ths_max
// Аналогично для угла phi

// attach_lkr2csi
// кластер LKr(башни) присоединяется к кластеру CsI, если выполняются соотношения
// fabs(lkr_theta-csi_theta) < THS_THETA && fabs(lkr_phi-csi_phi) < THS_PHI
// Здесь порог THS_THETA(в градусах) насчитывается исходя их карты
// lkr2csi_theta=nsig, ths_min, ths_max;
// THS_THETA=nsig*(lkr_dtheta+csi_dtheta)/2., где lkr_dtheta и csi_dtheta размеры
// кластеров. При этом,
// если THS_THETA<ths_min то THS_THETA=ths_min
// если THS_THETA>ths_max то THS_THETA=ths_max
// Аналогично для угла phi

// emc_debug=par;
// если этот параметр par>0 то в конце реконструкции события будет вызываться
// функция emc_debug(par), где параметр par отвечает за
// par=1 - печататать списки кластеров
// par=2 - печатать для кластера номера пришитых треков, кластеров, и списки плохих ячеек
// par=3 - печатать списки ячеек, входящие в кластер

// emc_debug_field
// параметр emc_debug_field=lkr, csi, str, str_track, dc_track позволяет
// запрещать ту или иную печатать. Можно например запретить печатать все, за 
// исключением информации по кластерам LKr(башни) поставив emc_debug_field=1,0,0,0,0;
// Работает при включенном emc_debug

// sim4exp_bad=1
// При вызове emc_run(nrun) при обработке моделирования из БД будут читаться списки
// плохих каналов для экспериментального захода с номером nrun.
